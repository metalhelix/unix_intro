<p><link href="./markdown.css" rel="stylesheet"></link></p>

<h1 id="unixprimerforbiologists">Unix Primer for Biologists</h1>

<h2 id="adaptedforstowers">Adapted for Stowers</h2>

<hr />

<h1 id="contents">Contents</h1>

<ul>
<li><a href="#whyunix">Why Unix</a></li>
<li><a href="#part1">Part 1</a> &#8212; Unix - Learning the essentials</li>
<li><a href="#part2">Part 2</a> &#8212; Advanced Unix</li>
</ul>

<hr />

<h2 id="whyunix">Why Unix?</h2>

<p>The <a href="http://en.wikipedia.org/wiki/Unix">Unix operating system</a> has been around since 1969. Back then there was no such thing as a graphical user interface. You typed everything. It may seem archaic to use a keyboard to issue commands today, but it&#8217;s much easier to automate keyboard tasks than mouse tasks. There are several variants of Unix (including <a href="http://en.wikipedia.org/wiki/Linux">Linux</a>), though the differences do not matter much. Though you may not have noticed it, Apple has been using Unix as the underlying operating system on all of their computers since 2001.</p>

<p>Increasingly, the raw output of biological research exists as <em>in silico</em> data, usually in the form of large text files. Unix is particularly suited to working with such files and has several powerful (and flexible) commands that can process your data for you. The real strength of learning Unix is that most of these commands can be combined in an almost unlimited fashion. So if you can learn just five Unix commands, you will be able to do a lot more than just five things.</p>

<h2 id="typeset">Typeset Conventions</h2>

<p>All of the code in these guides is written in constant-width font with line numbering. Here is an example with 3 lines:</p>

<pre><code>1. for ($i = 0; $i &lt; 10; $i++) { 
2.     print $i, &quot;\n&quot;; 
3. }
</code></pre>

<p>Text you are meant to type into a terminal is indented in constant-width font without line numbering. Here is an
example:</p>

<pre><code>ls -lrh
</code></pre>

<p>Sometimes a paragraph will include a reference to a Unix command, or a file that you should be working with, Any such text will be in a constant-width, boxed font. E.g.</p>

<p>Type the <code>pwd</code> command again.</p>

<p>Important or critical points will be styled like so:</p>

<blockquote>
<p><strong><em>This is an important point!</em></strong></p>
</blockquote>

<hr />

<h1 id="part1">Part 1: Unix - Learning the essentials</h1>

<h2 id="introductiontounix">Introduction to Unix</h2>

<p>These exercises will (hopefully) teach you to become comfortable when working in the environment of the Unix terminal. Unix contains many hundred of commands but you will probably use just 10 or so to achieve most of what you want to do.</p>

<p>You are probably used to working with programs like the Apple Finder or the Windows File Explorer to navigate around the hard drive of your computer. Some people are so used to using the mouse to move files, drag files to trash etc. that it can seem strange switching from this behavior to typing commands instead. Be patient, and try — as much as possible — to stay within world of the Unix terminal. Please make sure you complete and understand each task before moving on to the next one.</p>

<hr />

<h2 id="u1">U1. The Terminal</h2>

<p>A &#8216;terminal&#8217; is the common name for the program that does two main things. It allows you to type input to the computer (i.e. run programs, move/view files etc.) and it allows you to see output from those programs. All Unix machines will have a terminal program and on Apple computers, the terminal application is unsurprisingly named &#8216;Terminal&#8217;.</p>

<h4 id="u1.1">Task U1.1</h4>

<p>Use the &#8216;Spotlight&#8217; search tool (the little magnifying glass in the top right of the menu bar) to find, and then launch, Apple&#8217;s Terminal application: </p>

<figure>
<img src="./img/spotlight.png" alt="Spotlight" />
<figcaption>Spotlight</figcaption></figure>



<p>You should now see something that looks like the following (any text that appears inside your terminal window will look different):</p>

<figure>
<img src="./img/terminal.png" alt="Terminal application" />
<figcaption>Terminal application</figcaption></figure>



<p>Before we go any further, you should note that you can:</p>

<ul>
<li>make the text <strong>larger/smaller</strong> (hold down &#8216;command&#8217; (&#x2318;) and either &#8216;+&#8217; or &#8216;-&#8217;)</li>
<li><strong>resize</strong> the window (this will often be necessary)</li>
<li>have <strong>multiple terminal windows</strong> on screen (see the <em>Shell</em> menu)</li>
<li>have <strong>multiple tabs</strong> open within each window (again see the <em>Shell</em> menu)</li>
</ul>

<p>There will be many situations where it will be useful to have multiple terminals open and it will be a matter of
preference as to whether you want to have multiple windows, or one window with multiple tabs (there are keyboard
shortcuts for switching between windows, or moving between tabs).</p>

<hr />

<h2 id="u2">U2. Your first Unix command</h2>

<p>Unix keeps files arranged in a hierarchical structure. From the &#8216;top-level&#8217; of the computer, there will be a number of directories, each of which can contain files and subdirectories, and each of those in turn can of course contain more files and directories and so on, ad infinitum. It&#8217;s important to note that you will always be &#8220;in&#8221; a directory when using the terminal. The default behavior is that when you open a new terminal you start in your own &#8216;<em>home</em>&#8217; directory (on a Mac, this is the directory your <em>Music</em>, <em>Pictures</em>, and <em>Desktop</em> directory reside in).</p>

<p>To see what files are in our home directory, we need to use the <a href="http://en.wikipedia.org/wiki/Ls">ls</a> command. This command &#8216;lists&#8217; the contents of a directory. So why don&#8217;t they call the command &#8216;list&#8217; instead? Well, this is a good thing because typing long commands over and over again is tiring and time-consuming. There are many (frequently used) Unix commands that are just two or three letters. If we run the ls command we should see something like:</p>

<pre><code>gamma:~ jfv$ ls 
Application Shortcuts   Documents   Library 
Desktop                 Downloads 
gamma:~ jfv$
</code></pre>

<p>There are four things that you should note here:</p>

<ol>
<li>You will probably see a slightly <em>different</em> output to what is shown here, it depends on your computer. Don&#8217;t worry about that for now.</li>
<li>The <code>gamma:~ jfv$</code> text that you see is the Unix <a href="http://en.wikipedia.org/wiki/Command_line_interface">command prompt</a>. The command prompt is where we will be typing Unix commands. It is usually also configured to provide some useful information to the user. Here, it contains a user name (for me: <em>jfv</em>), the name of the machine that this user is working on (for me <em>gamma</em>), and the name of the current directory (&#8216;~&#8217; more on that later). Note that the command prompt might not look the same on different Unix systems. In this case, the $ sign marks the end of the prompt.</li>
<li>The output of the <code>ls</code> command lists a number of things. In this case, they are all directories, but they could also be files. We&#8217;ll learn how to tell them apart later on.</li>
<li>After the <code>ls</code> command finishes it produces a <strong>new command prompt</strong>, ready for you to type your next command.</li>
</ol>

<hr />

<h2 id="u3">U3: The Unix tree</h2>

<p>Looking at directories from within a Unix terminal can often seem confusing. But bear in mind that these directories are exactly the same type of folders that you can see if you use Apple&#8217;s graphical file-management program (known as <strong>The Finder</strong>). A tree analogy is often used when describing computer filesystems. From the root level (/) there can be one or more top level directories, though most Macs will have about a dozen. In the example below, we show just three. When you log in to a computer you are working with your files in your home directory, and this will nearly always be inside a &#8216;Users&#8217; directory. On many computers there will be multiple users.</p>

<p>All Macs have an applications directory where all the GUI (graphical user interface) programs are kept (e.g. iTunes, Microsoft Word, Terminal). Another directory that will be on all Macs is the Volumes directory. In addition to any attached <em>external</em> drives, the Volumes directory should also contain directories for every <em>internal</em> hard drive (of which there should be at least one, in this case it&#8217;s simply called &#8216;Mac&#8217;). </p>

<p>On other Unix systems, for instance a Linux distribution like <a href="http://www.ubuntu.com/">Ubuntu</a>, the names and contents of the directories will be different. However, the structure and navigation of the Unix tree will be exactly the same. Once you know how to get around in one Unix system, you can get around in all of them.</p>

<p>It will help to think of this tree when we come to copying and moving files. E.g. if we had a file in the &#8216;Code&#8217; directory and wanted to copy it to the &#8216;keith&#8217; directory, we would have to go <em>up</em> four levels to the root level, and then <em>down</em> two levels.</p>

<figure>
<img src="./img/directory_tree.png" alt="Example directory structure" />
<figcaption>Example directory structure</figcaption></figure>



<hr />

<h2 id="u4">U4: Finding out where you are</h2>

<p>There may be many hundreds or thousands of directories on any Unix machine, so how do you know which one you are in? The command
<a href="http://en.wikipedia.org/wiki/Pwd">pwd</a> will Print the <a href="http://en.wikipedia.org/wiki/Working_directory">Working Directory</a> - the directory you are currently in. That&#8217;s pretty much all this command does:</p>

<pre><code>gamma:~ jfv$ pwd 
/Users/jfv
</code></pre>

<p>When you log in to a Unix computer, you are typically placed into your <em>home</em> directory. </p>

<p>In this example, after we log in, we are placed in a directory called &#8216;jfv&#8217; which itself is a subdirectory of another directory called &#8216;Users&#8217;. Conversely, &#8216;Users&#8217; is the parent directory of &#8216;jfv&#8217;. The first forward slash that appears in a list of directory names always refers to the top level directory of the file system (known as the <a href="http://en.wikipedia.org/wiki/Root_directory">root directory</a>). The remaining forward slash (between &#8216;users&#8217; and &#8216;jfv&#8217;) delimits the various parts of the directory hierarchy. If you ever get &#8216;lost&#8217; in Unix, remember the <code>pwd</code> command.</p>

<p>As you learn Unix you will frequently type commands that don&#8217;t seem to work. Most of the time this will be because you are in the wrong directory, so it&#8217;s a really good habit to get used to running the <code>pwd</code> command a lot.</p>

<hr />

<h2 id="u5">U5: Getting from &#8216;A&#8217; to &#8216;B&#8217;</h2>

<p>We are in the home directory on the computer but we want to to work on the USB drive. To change directories in Unix, we
use the <a href="http://en.wikipedia.org/wiki/Cd_(command)">cd</a> command:</p>

<pre><code>gamma:~ jfv$ cd /Users/Shared
gamma:/Users/Shared jfv$ ls
# ... some set of files
gamma:/Users/Shared jfv$ pwd 
/Users/Shared
</code></pre>

<p>The first command reads as &#8220;change directory to the <code>Shared</code> directory which inside the <code>Users</code> directory which is in turn at the root level of the File System&#8221;.</p>

<hr />

<h2 id="u6">U6: Root is the root of (potential) evil</h2>

<p>In the previous example, we could have achieved the same result in three separate steps:</p>

<pre><code>$ cd /Users 
$ cd Shared 
</code></pre>

<p>Note that the second command <strong>does not include a forward slash</strong>. When you specify a directory that starts with a forward slash, you are referring to a directory that should exist one level below the root level of the computer. The forward slash means <em>the root</em>. What happens if you try the following two commands? The first command should produce an error message.</p>

<pre><code>$ cd Volumes 
$ cd /Volumes
</code></pre>

<p>The error is because without including a leading slash, Unix is trying to change to a &#8216;Volumes&#8217; directory <em>below your current level</em> in the file hierarchy (/Users/Shared), and there is no directory called <code>Volumes</code> at this location.</p>

<hr />

<h2 id="u7">U7: Up, up, and away</h2>

<p>Frequently, you will find that you want to go &#8216;upwards&#8217; one level in the directory hierarchy, i.e. one directory <strong>closer to the root</strong>. Two dots <code>..</code> are used in Unix to refer to the <em>parent</em> directory of wherever you are. Every directory has a parent except the root level of the computer:</p>

<pre><code>$ cd /Users/Shared
$ pwd 
/Users/Shared
$ cd .. 
$ pwd 
/Users
</code></pre>

<p>What if you wanted to navigate up <em>two</em> levels in the file system in one go? It&#8217;s very simple, just use two sets of the <code>..</code> operator, separated by a forward slash:</p>

<pre><code>$ cd /Users/Shared
$ pwd 
/Users/Shared
$ cd ../.. 
$ pwd 
/
</code></pre>

<hr />

<h2 id="u8">U8: I&#8217;m absolutely sure that this is all relative</h2>

<p>Using <code>cd ..</code> allows us to change directory <em>relative</em> to where we are now. You can also always change to a directory based on its <em>absolute</em> location. E.g. if you are working in the <code>/Users/Shared/Code</code> directory and you then want to change to the <code>/Users/Shared/Data</code> directory, then you could do either of the following:</p>

<pre><code>$ cd ../Data
</code></pre>

<p>or&#8230;</p>

<pre><code>$ cd /Users/Shared/Data
</code></pre>

<p>They both achieve the same thing, but the 2nd example requires that you know about the full <em>path</em> from the root level of the computer to your directory of interest (the &#8216;path&#8217; is an important concept in Unix). Sometimes it is quicker to change directories using the relative path, and other times it will be quicker to use the absolute path.</p>

<hr />

<h2 id="u9">U9: Time to go home</h2>

<p>Remember that the command prompt shows you the name of the directory that you are currently in, and that when you are in your home directory it shows you a tilde character (~) instead? This is because Unix uses the tilde character as a short-hand way of <a href="http://en.wikipedia.org/wiki/Tilde#Directories_and_URLs">specifying a home directory</a>.</p>

<h4 id="u9.1">Task U9.1</h4>

<p>See what happens when you try the following commands (use the <code>pwd</code> command after each one to confirm the results):</p>

<pre><code>$ cd / 
$ cd ~ 
$ cd / 
$ cd
</code></pre>

<p>Hopefully, you should find that <code>cd</code> and <code>cd ~</code> do the same thing, i.e. they take you back to your home directory (from wherever you were). Also notice how you can specify the single forward slash to refer to the root directory of the computer. When working with Unix you will frequently want to jump straight back to your home directory, and typing <code>cd</code> is a very quick way to get there.</p>

<hr />

<h2 id="u10">U10: Making the ls command more useful</h2>

<p>The <code>..</code> operator that we saw earlier can also be used with the <code>ls</code> command. Can you see how the following command is listing the contents of the root directory? If you want to test this, try running <code>ls /</code> and see if the output is any different.</p>

<pre><code>$ cd /Volumes/USB/Unix_and_Perl_course 
$ ls ../../.. 
Applications    Volumes     net
CRC             bin         oldlogins 
Developer       cores       private
Library         dev         sbin 
Network         etc         tmp 
Server          home        usr
System          mach_kernel var 
Users           mach_kernel.ctfsys
</code></pre>

<p>The <code>ls</code> command (like most Unix commands) has a <strong>set of options</strong> that can be added to the command to change the results. Command-line options in Unix are specified by using a dash (&#8216;-&#8217;) after the command name followed by various letters, numbers, or words. Sometimes these command line options are called <strong>flags</strong>. If you add the flag <code>-l</code> to the <code>ls</code> command it will give you a <em>longer</em> output compared to the default:</p>

<pre><code>$ ls -l ~
total 184
drwx------+ 41 jfv   SIMR01\Domain Users   1394 Aug 22 09:00 Desktop
drwx------+ 49 jfv   SIMR01\Domain Users   1666 Aug 13 16:00 Documents
drwx------+ 97 jfv   SIMR01\Domain Users   3298 Aug 22 09:04 Downloads
drwx------@ 23 jfv   SIMR01\Domain Users    782 Aug 15 12:06 Dropbox
# ... many more
</code></pre>

<p>For each file or directory we now see more information (including file ownership and modification times). The &#8216;d&#8217; at the start of each line indicates that these are directories</p>

<h4 id="u10.1">Task U10.1</h4>

<p>There are many, many different options for the ls command. Try out the following (against any directory of your choice) to see how the output changes.</p>

<pre><code>ls -l 
ls -R 
ls -l -t -r 
ls -lh
</code></pre>

<p>Note that the last example combine multiple options but only use one dash. This is a very common way of specifying multiple command-line options. You may be wondering what some of these options are doing. It&#8217;s time to learn about Unix documentation&#8230;.</p>

<hr />

<h2 id="u11">U11: Man your battle stations!</h2>

<p>If every Unix command has so many options, you might be wondering how you find out what they are and what they do. Well,
thankfully every Unix command has an associated &#8216;manual&#8217; that you can access by using the <code>man</code> command. E.g.</p>

<pre><code>$ man ls 
$ man cd
$ man man # yes even the man command has a manual page
</code></pre>

<p>When you are using the man command, press <code>space</code> to scroll down a page, <code>b</code> to go back a page, or <code>q</code> to quit. You can also use the <strong>up and down arrows</strong> to scroll a line at a time. The man command is actually using another Unix program, a text viewer called <code>less</code>, which we&#8217;ll come to later on.</p>

<p>Some Unix commands have very long manual pages, which might seem very confusing. It is typical though to always list the command line options early on in the documentation, so you shouldn&#8217;t have to read too much in order to find out what a command-line option is doing.</p>

<hr />

<h2 id="u12">U12: Making new directories</h2>

<p>If we want to make a new directory (e.g. to store some work related data), we can use the
<a href="http://en.wikipedia.org/wiki/Tilde#Directories_and_URLs">mkdir</a> command:</p>

<pre><code>$ cd /tmp
$ mkdir Work
$ ls
# should see 'Work' in the list
$ mkdir Temp1 
$ cd Temp1 
$ mkdir Temp2 
$ cd Temp2 
$ pwd 
/tmp/Temp1/Temp2
</code></pre>

<p>In the last example we created the two temp directories in two separate steps. If we had used the <code>-p</code> option of the <code>mkdir</code> command we could have done this in one step. E.g.</p>

<pre><code>$ mkdir -p Temp1/Temp2
</code></pre>

<h4 id="u12.1">Task U12.1</h4>

<p>Practice creating some directories and navigating between them using the <code>cd</code> command. Try changing
directories using both the <em>absolute</em> as well as the <em>relative</em> path (see section <a href="#u8">U8</a>).</p>

<hr />

<h2 id="u13">U13: Time to tidy up</h2>

<p>We now have a few (empty) directories that we should remove. To do this use the <a href="http://en.wikipedia.org/wiki/Rmdir">rmdir</a> command, this will <em>only remove empty directories</em> so it is quite safe to use. If you want to know more about this command (or any Unix command), then remember that you can just look at its man page.</p>

<pre><code>$ cd /tmp
$ rmdir Work
</code></pre>

<h4 id="u13.1">Task U13.1</h4>

<p>Remove the remaining empty Temp directories that you have created. First try to remove <code>Temp1</code> first, see that you get an error message about the directory not being empty.</p>

<hr />

<h2 id="u14">U14: The art of typing less to do more</h2>

<p>Saving keystrokes may not seem important, but the longer that you spend typing in a terminal window, the happier you will be if you can reduce the time you spend repeating the same or similar commands.</p>

<p>So the best Unix tip to learn early on is that you can <a href="http://en.wikipedia.org/wiki/Command_line_completion">tab complete</a> the names of files and programs on most Unix systems. Type enough letters that uniquely identify the name of a file, directory or program and press tab&#8230;Unix will do the rest. </p>

<p>For example, if you type &#8216;tou&#8217; and then press tab, Unix will <strong>autocomplete</strong> the word to <code>touch</code> (which we will learn more about in a minute). In this case, tab completion will occur because there are no other Unix commands that start with &#8216;tou&#8217;. If pressing tab doesn&#8217;t do anything, then you have not have typed enough unique characters. In this case <strong>pressing tab twice</strong> will show you all possible completions. This trick can save you a LOT of typing.</p>

<h4 id="u14.1">Task U14.1</h4>

<p>Navigate to your home directory, and then use the <code>cd</code> command to change to the <code>/Users/Shared</code> directory. Use tab completion for each directory name. This should take significantly fewer keystrokes then typing it out all manually.</p>

<p>Another great time-saver is that Unix stores a list of all the commands that you have typed in each login session. You can access this list by using the <a href="http://en.wikipedia.org/wiki/History_(Unix)">history</a> command or more simply by using the <strong>up and down arrows</strong> to access anything from your history. So if you type a long command but make a mistake, press the up arrow and then you can use the left and right arrows to move the cursor in order to make a change.</p>

<hr />

<h2 id="u15">U15: U <em>can</em> touch this</h2>

<p>The following sections will deal with Unix commands that help us to work with files, i.e. copy files to/from places, move files, rename files, remove files, and most importantly, look at files. Remember, we want to be able to do all of these things without leaving the terminal. First, we need to have some files to play with. The Unix command <a href="http://en.wikipedia.org/wiki/Command_line_completion">touch</a> will let us create a new, empty file. The touch command does other things too, but for now we just want a couple of files to work with.</p>

<pre><code>$ cd /tmp/
$ mkdir Work
$ cd Work
$ touch heaven.txt 
$ touch earth.txt 
$ ls
earth.txt     heaven.txt
</code></pre>

<hr />

<h2 id="u16">U16: Moving heaven and earth</h2>

<p>Now, let&#8217;s assume that we want to move these files to a new directory (&#8216;Temp&#8217;). We will do this using the Unix <a href="http://en.wikipedia.org/wiki/Mv">mv</a> (move) command:</p>

<pre><code>$ mkdir Temp 
$ mv heaven.txt Temp/ 
$ mv earth.txt Temp/ 
$ ls 
Temp 
$ ls Temp/
earth.txt heaven.txt
</code></pre>

<p>For the <code>mv</code> command, we always have to specify a source file (or directory) that we want to move, and then specify a
target location. If we had wanted to we could have moved both files in one go by typing any of the following commands:</p>

<pre><code>$ mv *.txt Temp/ 
$ mv *t Temp/ 
$ mv *ea* Temp/
</code></pre>

<p>The asterisk <code>*</code> acts as a <a href="http://en.wikipedia.org/wiki/Wildcard_character">wild-card character</a>, essentially meaning &#8216;match anything&#8217;. The second example works because there are no other files or directories in the directory that end with the letters &#8216;t&#8217; (if there was, then they would be copied too). Likewise, the third example works because only those two files contain the letters &#8216;ea&#8217; in their names. Using wild-card characters can save you a lot of typing.</p>

<h4 id="u16.1">Task U16.1</h4>

<p>Use <code>touch</code> to create three files called &#8216;fat&#8217;, &#8216;fit&#8217;, and &#8216;feet&#8217; inside the Temp directory. I.e.</p>

<pre><code>$ cd Temp
$ touch fat fit feet
</code></pre>

<p>Then type either <code>ls f?t</code> or <code>ls f*t</code> and see what happens. The ? character is also a wild-card but with a slightly different meaning. Try typing <code>ls f??t</code> as well.</p>

<hr />

<h2 id="u17">U17: Renaming files</h2>

<p>In the earlier example, the destination for the <code>mv</code> command was a directory name (Temp). So we moved a file from its source location to a target location (&#8216;source&#8217; and &#8216;target&#8217; are important concepts for many Unix commands). But note that the target could have also been a (different) file name, rather than a directory. E.g. let&#8217;s make a new file and move it whilst renaming it at the same time:</p>

<pre><code>$ touch rags 
$ ls 
Temp  rags 
$ mv rags Temp/riches 
$ ls Temp/
earth.txt      heaven.txt     riches
</code></pre>

<p>In this example we create a new file (&#8216;rags&#8217;) and move it to a new location and in the process change the name (to &#8216;riches&#8217;). So <code>mv</code> can rename a file as well as move it. The logical extension of this is using <code>mv</code> to rename a file without moving it (you have to use <code>mv</code> to do this as Unix <strong>does not</strong> (usually) have a separate &#8216;rename&#8217; command):</p>

<pre><code>$ mv Temp/riches Temp/rags 
$ ls Temp/ 
earth.txt      heaven.txt     rags
</code></pre>

<hr />

<h2 id="u18">U18: Stay on target</h2>

<p>It is important to understand that as long as you have specified a <strong>source</strong> and a <strong>target</strong> location when you are moving a file, then it doesn&#8217;t matter what your current directory is. You can move or copy things within the same directory or between different directories regardless of whether you are &#8220;in&#8221; any of those directories. Moving directories is just like moving files:</p>

<pre><code>$ mkdir Temp2 
$ ls 
Temp  Temp2 
$ mv Temp2 Temp/ 
$ ls Temp/
Temp2       earth.txt       heaven.txt  rags
</code></pre>

<p>This step moves the Temp2 directory inside the Temp directory.</p>

<h4 id="u18.1">Task U18.1</h4>

<p>Create another Temp directory (Temp3) and then change directory to your home directory (~). <strong>Without</strong> changing directory, move the Temp3 directory to inside the /tmp/Work/Temp directory.</p>

<hr />

<h2 id="u19">U19: Here, there, and everywhere</h2>

<p>The philosophy of <em>not having to be in a directory to do something in that directory</em>, extends to just about <strong>any operation</strong> that you might want to do in Unix. Just because we need to do something with file X, it doesn&#8217;t necessarily mean that we have to change directory to wherever file X is located. Let&#8217;s assume that we just want to quickly check what is in the Data directory before continuing work with whatever we were previously doing in /tmp/Work. Which of the following looks more convenient:</p>

<pre><code>$ cd /tmp 
$ ls 
# some temp files
$ cd ..
</code></pre>

<p>or&#8230;</p>

<pre><code>$ ls /tmp 
# some temp files
</code></pre>

<p>In the first example, we change directories just to run the ls command, and then we change directories back to where we were again. The second example shows how we could have just stayed where we were.</p>

<hr />

<h2 id="u20">U20: To slash or not to slash?</h2>

<h4 id="u20.1">Task U20.1</h4>

<p>Run the following two commands and compare the output</p>

<pre><code>$ ls Documentation

$ ls Documentation/
</code></pre>

<p>The two examples are not quite identical, but they produce identical output. So does the trailing slash character in the second example matter? Well not really. In both cases we have a directory named &#8216;Documentation&#8217; and it is optional as to whether you include the trailing slash. When you tab complete any Unix directory name, you will find that a trailing slash character is automatically added for you. This becomes useful when that directory contains subdirectories which you also want to tab complete.</p>

<p>I.e. imagine if you had to type the following (to access a buried directory &#8216;ggg&#8217;) and tab-completion <em>didn&#8217;t</em> add the trailing slash characters. You&#8217;d have to type the seven slashes yourself.</p>

<pre><code>$ cd aaa/bbb/ccc/ddd/eee/fff/ggg/
</code></pre>

<hr />

<h2 id="u21">U21: The most dangerous Unix command you will ever learn!</h2>

<p>You&#8217;ve seen how to remove a directory with the <code>rmdir</code> command, but <code>rmdir</code> won&#8217;t remove directories if they contain any files. So how can we remove the files we have created (in /Volumes/USB/Unix_and_Perl_course/Temp)? In order to do this, we will have to use the <a href="http://en.wikipedia.org/wiki/Rm_(Unix)">rm</a> (remove) command.</p>

<blockquote>
<p><strong><em>Please read the next section VERY carefully. Misuse of the rm command can lead to needless death &amp; destruction</em></strong> </p>
</blockquote>

<p>Potentially, <code>rm</code> is a very dangerous command; if you delete something with <code>rm</code>, you will not get it back! It does <strong>not</strong> go into the trash or recycle can, it is permanently removed. It is possible to delete everything in your home directory (all directories and subdirectories) with <code>rm</code>, that is why it is such a dangerous command.</p>

<p>Let me repeat that last part again. It is possible to delete EVERY file you have ever created with the <code>rm</code> command. Are you scared yet? You should be. Luckily there is a way of making <code>rm</code> a little bit safer. We can use it with the <code>-i</code> command-line option which will ask for confirmation before deleting anything:</p>

<pre><code>$ pwd 
/tmp/Work
$ ls 
Temp2       Temp3       earth.txt   heaven.txt  rags 
$ rm -i earth.txt 
remove earth.txt? y 
$ rm -i heaven.txt 
remove heaven.txt? y
</code></pre>

<p>We could have simplified this step by using a wild-card (e.g. <code>rm -i *.txt</code>).</p>

<h4 id="u21.1">Task U21.1</h4>

<p>Remove the last file in the Temp directory (&#8216;rags&#8217;) and then remove the two empty directories (Temp 2 &amp; Temp3).</p>

<hr />

<h2 id="u22">U22: Go forth and multiply</h2>

<p>Copying files with the <a href="http://en.wikipedia.org/wiki/Cp_(Unix)">cp</a> (copy) command is very similar to moving them. Remember to always specify a source and a target location. Let&#8217;s create a new file and make a copy of it.</p>

<pre><code>$ touch file1 
$ cp file1 file2 
$ ls 
file1   file2
</code></pre>

<p>What if we wanted to copy files from a different directory to our current directory? Let&#8217;s put a file in our home
directory (specified by &#8216;~&#8217; remember) and copy it to your current directory:</p>

<pre><code>$ touch ~/file3 
$ ls 
file1   file2 
$ cp ~/file3 . 
$ ls file1 file2 file3
</code></pre>

<p>This last step introduces another new concept. In Unix, the <strong>current directory</strong> can be represented by a &#8216;.&#8217; (dot) character. You will mostly use this only for copying files to the current directory that you are in. But just to make a quick point, compare the following:</p>

<pre><code>$ ls 
$ ls . 
$ ls ./
</code></pre>

<p>In this case, using the dot is somewhat pointless because <code>ls</code> will already list the contents of the current directory by default. Also note again how the trailing slash is optional.</p>

<p>Let&#8217;s try the opposite situation and copy these files back to the home directory (even though one of them is already there). The default behavior of copy is to <strong>overwrite</strong> (without warning) files that have the same name, so be careful.</p>

<pre><code>$ cp file* ~/
</code></pre>

<p>Based on what we have already covered, do you think the trailing slash in &#8216;~/&#8217; is necessary? </p>

<hr />

<h2 id="u23">U23: Going deeper and deeper</h2>

<p>The <code>cp</code> command also allows us (with the use of a command-line option) to copy entire directories (also note how the <code>ls</code> command in this example is used to specify multiple directories):</p>

<pre><code>$ mkdir Storage 
$ mv file* Storage/ 
$ ls 
Storage 
$ cp -R Storage Storage2 
$ ls Storage Storage2 
Storage:
file1   file2   file3

Storage2: 
file1   file2   file3
</code></pre>

<h4 id="u23.1">Task U23.1</h4>

<p>The <code>-R</code> option means &#8216;copy recursively&#8217;, many other Unix commands also have a similar option. See what happens if you don&#8217;t include the <code>-R</code> option. We&#8217;ve finished with all of these temporary files now. Make sure you remove the Temp directory and its contents (remember to use <code>rm -i</code> unless you really know what you are doing).</p>

<hr />

<h2 id="u24">U24: When things go wrong</h2>

<p>At this point in the course, you may have tried typing some of these commands and have found that things did not work as expected. Some people will then assume that the computer doesn&#8217;t like them and that it is being deliberately mischievous. The more likely explanation is that you made a typing error. Maybe you have seen one the following error messages:</p>

<pre><code>$ ls Codee 
ls: Codee: No such file or directory

$ cp Data/Unix_test_files/* Docmentation 
usage: cp [-R [-H | -L | -P]] [-fi | -n] [-pvX] source_file target_file 
       cp [-R [-H | -L | -P]] [-fi | -n] [-pvX] source_file ... target_directory
</code></pre>

<p>In both cases, we included a deliberate typo when specifying the name of the directories. With the <code>ls</code> command, we get a fairly useful error message. With the <code>cp</code> command we get a more cryptic message that reveals the correct usage statement for this command. In general, if a command fails, check your current directory (<code>pwd</code>) and check that all the files or directories that you mention actually exist (and are in the right place). Many errors occur because people are not in the right directory! </p>

<hr />

<h2 id="u25">U25: Jumping (Air) ship to another computer</h2>

<p>Up until this point, we have been working with the Unix system you are sitting in front of, namely your laptop. Another powerful ability of Unix systems is the ability to easily connect to other computers and run commands on them, from the command line, as if you were at the computer itself.</p>

<p>Why would you want to do this? Sometimes a file or resource is only present on a particular machine. Sometimes your computer is not powerful enough to complete a complicated task, and you need a bigger and better machine. Sometimes you just don&#8217;t want to keep your laptop open all night while a program runs. There are many reasons why you might want to execute commands on another machine.</p>

<p>We are going to use the command <a href="http://en.wikipedia.org/wiki/Secure_Shell">ssh</a> to connect to another computer. <code>ssh</code> stands for <strong>secure shell</strong>. The <em>shell</em> is another term for the command line. This process is <em>secure</em> in the sense that it encrypts the communication between computers so malicious entities cannot see it.</p>

<p>Let&#8217;s <code>ssh</code> to a computer with the name <code>genekc03</code>. This is a machine on the local Stowers network.</p>

<pre><code>$ ssh genekc03
The authenticity of host 'genekc03 (10.0.xx.xx)' can't be established.
RSA key fingerprint is ba:xx:xx:9a:58:28:94:85:68:7f:d1:2f:af.
Are you sure you want to continue connecting (yes/no)?
</code></pre>

<p>What&#8217;s all this? Part of what it means to be <em>secure</em>. We can type <code>yes</code> to answer the question</p>

<p>Now it will ask for our password. This is your <em>Unix</em> password, that should have been provided to you.</p>

<p>You should end up seeing:</p>

<pre><code>jfv genekc03 ~$
</code></pre>

<p>Where <code>jfv</code> is actually your username. You are now logged into <code>genekc03</code> ! You can practice some of the non-destructive commands in your home directory on <code>genekc03</code>.</p>

<pre><code>$ pwd
$ ls
$ touch test.txt
</code></pre>

<p>As you might expect, all the commands that worked on your Mac will work on this machine, even though it is running a completely different version of Unix.</p>

<p>To get out of <code>genekc03</code>&#8217;s head and back to your local machine, you can type <code>exit</code></p>

<pre><code>$ exit
logout
Connection to genekc03 closed.
</code></pre>

<hr />

<h2 id="u26">U26: Less is more</h2>

<p>So far we have covered listing the contents of directories and moving/copying/deleting either files and/or directories. Now we will quickly cover how you can look at files; in Unix the <a href="http://en.wikipedia.org/wiki/Less_(Unix)">less</a> command lets you view (but not edit) text files. Let&#8217;s take a look at a file of <em>Arabidopsis thaliana</em> protein sequences:</p>

<pre><code>$ ssh genekc03
$ cd /n/core/Bioinformatics/Unix_Course
$ less Data/Arabidopsis/At_proteins.fasta
</code></pre>

<p>When you are using less, you can bring up a page of help commands by pressing <code>h</code>, scroll forward a page by pressing <code>space</code>, or go forward or backwards one line at a time by pressing <code>j</code> or <code>k</code>. To exit less, press <code>q</code> (for quit). The <code>less</code> program also does about a million other useful things (including text searching).</p>

<hr />

<h2 id="u27">U27: Fire the editor</h2>

<p>We&#8217;ve moved, touched, copied, and looked at files so far. Now lets try editing one.</p>

<pre><code>$ cd /tmp/Work
$ touch profile
$ nano profile
</code></pre>

<p>You should see the following appear in your terminal:</p>

<figure>
<img src="./img/nano.png" alt="the nano editor" />
<figcaption>the nano editor</figcaption></figure>



<p>The bottom of the nano window shows you a list of simple commands which are all accessible by typing &#8216;Control&#8217; plus a letter. E.g. Control + X exits the program.</p>

<h4 id="u27.1">Task U27.1</h4>

<p>Type some text in the editor and then save it (Control + O). Nano will ask if you want to &#8216;save the modified buffer&#8217; and then ask if you want to keep the same name. Then exit nano (Control + X) and use <code>less</code> to confirm that the profile file contains the text you added.</p>

<hr />

<h2 id="u28">U28: Sticking to the script</h2>

<p>Unix can also be used as a programming language just to let you create your own &#8216;programs&#8217; which are really just text files with commands in them.</p>

<p>So how do you make a Unix script (which are commonly called &#8216;shell scripts&#8217;)? At the simplest level, we just write one or more Unix commands to a file and then treat that file as if it was any other Unix command or program.</p>

<h4 id="u28.1">Task U28.1</h4>

<p>Copy the following two lines to a file (using <code>nano</code>). Name that file hello.sh (shell scripts are typically given a .sh extension).</p>

<pre><code># my first Unix shell script 
echo &quot;Hello World&quot;
</code></pre>

<p>Programs in Unix need permission to be run. We will normally always have to type the following for any script that we create:</p>

<pre><code>$ chmod +x hello.sh
</code></pre>

<p>This would use the <a href="http://en.wikipedia.org/wiki/Chmod">chmod</a> to add <em>executable</em> permissions (+x) to the file called &#8216;hello.sh&#8217;. Without it, your script won&#8217;t run.</p>

<p>When you have done that, simply type &#8216;hello.sh&#8217; and see what happens. If it worked, then it should have printed &#8216;Hello world&#8217;. This very simple script uses the Unix command <a href="http://en.wikipedia.org/wiki/Echo_(command)">echo</a> which just prints output to the screen. Also note the comment that precedes the <code>echo</code> command which starts with the <code>#</code>. Comments are useful to people reading the script, and they are completely ignored when running the program.</p>

<hr />

<h2 id="u29">U29: Ask for permission</h2>

<p>The chmod command can also modify read and write permissions for files, and change any of the three sets of permissions (read, write, execute) at the level of &#8216;user&#8217;, &#8216;group&#8217;, and &#8216;other&#8217;. You probably won&#8217;t need to know any more about the chmod command other than you need to use it to make scripts executable.</p>

<hr />

<h2 id="u30">U30: The power of shell scripts</h2>

<p>Time to make some Unix shell scripts that might actually be useful.</p>

<h4 id="u30.1">Task U30.1</h4>

<p>Look in the Data/Unix_test_files directory. You should see several files (all are empty) and four directories. Now put the following information into a shell script (using <code>nano</code>) and save it as cleanup.sh.</p>

<pre><code>#!/bin/bash
mv *.txt Text 
mv *.jpg Pictures 
mv *.mp3 Music 
mv *.fa Sequences
</code></pre>

<p>Make sure you are in the right directory and then run this script. It should place the relevant files in the correct directories. This is a relatively simple use of shell scripting. As you can see the script just contains regular Unix commands that you might type at the command prompt. But if you had to do this type of file sorting every day, and had many different types of file, then it would save you a lot of time.</p>

<p>Did you notice the #!/bin/bash line in this script? There are several different types of shell script in Unix, and this line makes it clearer that a) that this is actually a file that can be treated as a program and b) that it will be a bash script (bash is a type of Unix). As a general rule, all type of scriptable programming languages should have a similar line as the first line in the program.</p>

<h4 id="u30.2">Task U30.2</h4>

<p>Here is another script. Copy this information into a file called change_file_extension.sh and again place that file in the Code directory.</p>

<pre><code>#!/bin/bash

for filename in *.$1 
do 
    mv $filename ${filename%$1}$2 
done
</code></pre>

<p>Now go to the <code>Data/Unix_test_files/Text</code> directory. If you have run the exercise from Task [U32.1] then your text directory should now contain three files. Run the following command:</p>

<pre><code>$ change_file_extension.sh txt text
</code></pre>

<p>Now run the <code>ls</code> command to see what has happened to the files in the directory. You should see that all the files that ended with &#8216;txt&#8217; now end with &#8216;text&#8217;. Try using this script to change the file extensions of other files.</p>

<p>Hopefully you can see how a relatively simple Unix shell script can be potentially very useful.</p>

<hr />

<h2 id="endofpart1.">End of part 1.</h2>

<hr />

<h1 id="part2">Part 2: Advanced Unix</h1>

<h2 id="howtobecomeaunixpoweruser">How to Become a Unix power user</h2>

<p>The commands that you have learnt so far are essential for doing any work in Unix but they don&#8217;t really let you do anything that is very useful. The following sections will introduce a few new commands that will start to show you how powerful Unix is.</p>

<hr />

<h2 id="u33">U33: Match making</h2>

<p>You will often want to search files to find lines that match a certain pattern. The Unix command <a href="http://en.wikipedia.org/wiki/Grep">grep</a> does this (and much more). You might already know that FASTA files (used frequently in bioinformatics) have a simple format: one header line which must start with a &#8216;&gt;&#8217; character, followed by a DNA or protein sequence on subsequent lines. To find only those header lines in a FASTA file, we can use grep, which just requires you specify a pattern to search for, and one or more files to search:</p>

<pre><code>$ cd Data/Arabidopsis/ 
$ grep &quot;&gt;&quot; intron_IME_data.fasta

&gt;AT1G68260.1_i1_204_CDS 
&gt;AT1G68260.1_i2_457_CDS 
&gt;AT1G68260.1_i3_1286_CDS 
&gt;AT1G68260.1_i4_1464_CDS 
.
.
.
</code></pre>

<p>This will produce lots of output which will flood past your screen. If you ever want to stop a program running in Unix, you can type Control+C (this sends an interrupt signal which should stop most Unix programs). The grep command has many different command-line options (type <code>man grep</code> to see them all), and one common option is to get <code>grep</code> to show lines that don&#8217;t match your input pattern. You can do this with the -v option and in this example we are seeing just the sequence part of the FASTA file.</p>

<pre><code>$ grep -v &quot;&gt;&quot; intron_IME_data.fasta

GTATACACATCTCTCTACTTTCATATTTTGCATCTCTAACGAAATCGGATTCCGTCGTTG
TGAAATTGAGTTTTCGGATTCAGTGTTGTCGAGATTCTATATCTGATTCAGTGATCTAAT 
GATTCTGATTGAAAATCTTCGCTATTGTACAG
GTTAGTTTTCAATGTTGCTGCTTCTGATTGTTGAAAGTGTTCATACATTTGTGAATTTAG
TTGATAAAATCTGAACTCTGCATGATCAAAGTTACTTCTTTACTTAGTTTGACAGGGACT
TTTTTTGTGAATGTGGTTGAGTAGAATTTAGGGCTTTGGATTAAATGTGACAAGATTTTG
.
.
.
</code></pre>

<hr />

<h2 id="u34">U34: Your first ever Unix pipe</h2>

<p>By now, you might be getting a bit fed up of waiting for the <code>grep</code> command to finish, or you might want a cleaner way of controlling things without having to reach for Ctrl-C. Ideally, you might want to look at the output from any command in a controlled manner, i.e. you might want to use a Unix program like less to view the output.</p>

<p>This is very easy to do in Unix, you can send the output from any command to any other Unix program (as long as the second program accepts input of some sort). We do this by using what is known as a <a href="http://en.wikipedia.org/wiki/Pipe_(Unix)">pipe</a>. This is implemented using the &#8216;|&#8217; character (which is a character which always seems to be on different keys depending on the keyboard that you are using). Think of the pipe as simply connecting two Unix programs. In this next example we send the output from <code>grep</code> down a pipe to the less program. Let&#8217;s imagine that we just want to see lines in the input file which contain the pattern &#8220;ATGTGA&#8221; (a potential start and stop codon combined):</p>

<pre><code>$ grep &quot;ATGTGA&quot; intron_IME_data.fasta | less

TTTTTTGTGAATGTGGTTGAGTAGAATTTAGGGCTTTGGATTAAATGTGACAAGATTTTG
CTGAATGTGACTGGAAGAATGAAATGTGTTAAGATCTTGTTCGTTAAGTTTAGAGTCTTG
GGTGGAATGAATTTATGTATCATGTGATAGCTGTTGCATTACAAGATGTAATTTTGCAAA
GTCTATGTGATGGCCATAGCCCATAGTGACTGATAGCTCCTTACTTTGTTTTTTTTTTCT
TTACTTGCAAAATTCCATGTGATTTTTTATATTACTTTGAAGAATTTTATAATATATTTT
TTGCATCAAGATATGTGACATCTTCAAAAAGATAACTTGTGAGAAGACAATTATAATATG
GTAACTTATTTATTGATTGAATCAGTAACTGTATTGTTATCATGATTTGTGAATATGTGA
AATCTTTGTGGTGGGTCTACGATATGAGCTGTCAATATATTTTTGTTTATACATGTGATC
GTATGTGAGCAAACGATGTCTCGTTTTCTCTCTCTCAATGATCAAGCACCTAACTTAAAT\
.
.
.
</code></pre>

<p>Notice that you still have control of your output as you are now in the <code>less</code> program. If you press the forward slash (/) key in <code>less</code>, you can then specify a search pattern. Type ATGTGA after the slash and press enter. The <code>less</code> program will highlight the location of these matches on each line. Note that <code>grep</code> matches patterns on a per line basis. So if one line ended ATG and the next line started TGA, then <code>grep</code> would not find it.</p>

<blockquote>
<p><strong><em>Any time you run a Unix program or command that outputs a lot of text to the screen, you can instead pipe that output into the <code>less</code> program.</em></strong></p>
</blockquote>

<hr />

<h2 id="u35">U35: Heads and tails</h2>

<p>Sometimes we do not want to use <code>less</code> to see <em>all</em> of the output from a command like grep. We might just want to see a few lines to get a feeling for what the output looks like, or just check that our program (or Unix command) is working properly. There are two useful Unix commands for doing this: head and tail. These commands show (by default) the first or last 10 lines of a file (though it is easy to specify more or fewer lines of output). So now, let&#8217;s look for another pattern which might be in all the sequence files in the directory. If we didn&#8217;t know whether the DNA/protein sequence in a FASTA files was in upper-case or lower-case letters, then we could use the <code>-i</code> option of <code>grep</code> which &#8216;ignores&#8217; case when searching:</p>

<pre><code>$ grep -i ACGTC * | head
At_proteins.fasta:TYRSPRCNSAVCSRAGSIACGTCFSPPRPGCSNNTCGAFPDNSITGWATSGEFALDVVSIQSTNGSNPGRFVKIPNLIFS
At_proteins.fasta:FRRYGHYISSDVFRRFKGSNGNFKESLTGYAKGMLSLYEAAHLGTTKDYILQEALSFTSSHLESLAACGTCPPHLSVHIQ
At_proteins.fasta:MAISKALIASLLISLLVLQLVQADVENSQKKNGYAKKIDCGSACVARCRLSRRPRLCHRACGTCCYRCNCVPPGTYGNYD
At_proteins.fasta:MAVFRVLLASLLISLLVLDFVHADMVTSNDAPKIDCNSRCQERCSLSSRPNLCHRACGTCCARCNCVAPGTSGNYDKCPC
chr1.fasta:TGTCTACTGATTTGATGTTTTCCTAAACTGTTGATTCGTTTCAGGTCAACCAATCACGTCAACGAAATTCAGGATCTTA
chr1.fasta:TATGCTGCAAGTACCAGTCAATTTTAGTATGGGAAACTATAAACATGTATAATCAACCAATGAACACGTCAATAACCTA
chr1.fasta:TTGAACAGCTTAGGGTGAAAATTATGATCCGTAGAGACAGCATTTAAAAGTTCCTTACGTCCACGTAAAATAATATATC
chr1.fasta:GGGATCACGAGTCTGTTGAGTTTTCCGACGTCGCTTGGTGTTACCACTTTGTCGAACATGTGTTCTTTCTCCGGAGGTG
chr1.fasta:CTGCAAAGGCCTACCTGTTTGTCCCTGTTACTGACAATACGTCTATGGAACCCATAAAAGGGATCAACTGGGAATTGGT
chr1.fasta:ACGTCGAAGGGGGTAAGATTGCAGCTAATCATTTGATGAAATGGATTGGGATTCACGTGGAGGATGATCCTGATGAAGT
</code></pre>

<p>The <code>*</code> character acts as a wildcard meaning &#8216;search all files in the current directory&#8217; and the <code>head</code> command restricts the total amount of output to 10 lines. Notice that the output also includes the name of the file containing the matching pattern. In this case, the <code>grep</code> command finds the ACGTC pattern in four protein sequences and several lines of the the chromosome 1 DNA sequence (we don&#8217;t know how many exactly because the head command is only giving us ten lines of output).</p>

<hr />

<h2 id="u36">U36: Getting fancy with regular expressions</h2>

<p>A concept that is supported by many Unix programs and also by most programming languages (including Perl) is that of using <a href="http://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>. These allow you to specify search patterns which are quite complex and really help restrict the huge amount of data that you might be searching for to some very specific lines of output. E.g. you might want to find lines that start with an &#8216;ATG&#8217; and finish with &#8216;TGA&#8217; but which have at least three AC dinucleotides in the middle:</p>

<pre><code>$ grep &quot;^ATG.*ACACAC.*TGA$&quot; chr1.fasta

ATGAACCTTGTACTTCACCGGGTGCCCTCAAAGACGTTCTGCTCGGAAGGTTTGTCTTACACACTTTGATGTCAAATGA
ATGATAGCTCAACCACGAAATGTCATTACCTGAAACCCTTAAACACACTCTACCTCAAACTTACTGGTAAAAACATTGA
ATGCATACCTCAGTTGCATCCCGGCGCAGGGCAAGCATACCCGCTTCAACACACACTGCTTTGAGTTGAGCTCCATTGA
</code></pre>

<p>You&#8217;ll learn more about regular expressions when you learn Perl. The <code>^</code> character is a special character that tells <code>grep</code> to only match a pattern if it occurs at the start of a line. Similarly, the <code>$</code> tells <code>grep</code> to match patterns that occur at the end of the line.</p>

<h4 id="u36.1">Task U36.1</h4>

<p>The <code>.</code> and <code>*</code> characters are also special characters that form part of the regular expression. Try to understand how the following patterns all differ. Try using each of these these patterns with <code>grep</code> against any one of the sequence files. Can you predict which of the five patterns will generate the most matches?</p>

<pre><code>ACGT 
AC.GT 
AC*GT 
AC.*GT 
</code></pre>

<blockquote>
<p><strong><em>The asterisk in a regular expression is similar to, but NOT the same, as the other asterisks that we have seen so far. An asterisk in a regular expression means: &#8216;match zero or more of the preceding character or pattern&#8217;.</em></strong></p>
</blockquote>

<p>Try searching for the following patterns to ensure you understand what <code>.</code> and <code>*</code> are doing:</p>

<pre><code>A...T 
AG*T 
A*C*G*T*
</code></pre>

<hr />

<h2 id="u37">U37: Counting with <code>grep</code></h2>

<p>Rather than showing you the lines that match a certain pattern, <code>grep</code> can also just give you a count of how many lines match. This is one of the frequently used <code>grep</code> options. Running <code>grep -c</code> simply counts how many lines match the specified pattern. It doesn&#8217;t show you the lines themselves, just a number:</p>

<pre><code>$ grep -c i2 intron_IME_data.fasta 
9785
</code></pre>

<h4 id="u37.1">Task U37.1</h4>

<p>Count how many times each pattern from Task <a href="#u36.1">U36.1</a> occurs in all of the sequence files (specifying <code>*.fasta</code> will allow you to specify all sequence files).</p>

<hr />

<h2 id="u38">U38: Regular expressions in <code>less</code></h2>

<p>You have seen already how you can use <code>less</code> to view files, and also to search for patterns. If you are viewing a file with <code>less</code>, you can type a forward-slash <code>/</code> character, and this allows you to then specify a pattern and it will then search for (and highlight) all matches to that pattern. Technically it is searching forward from whatever point you are at in the file. You can also type a question-mark <code>?</code> and <code>less</code> will allow you to search backwards. The real bonus is that the patterns you specify can be regular expressions.</p>

<h4 id="u38.1">Task U38.1</h4>

<p>Try viewing a sequence file with <code>less</code> and then searching for a pattern such as <code>ATCG.*TAG$</code>. This should make it easier to see exactly where your regular expression pattern matches. After typing a forward-slash (or a question-mark), you can press the up and down arrows to select previous searches.</p>

<hr />

<h2 id="u39">U39: Let me transl(iter)ate that for you</h2>

<p>We have seen that these sequence files contain upper-case characters. What if we wanted to turn them into lower-case
characters (because maybe another bioinformatics program will only work if they are lower-case)? The Unix command <a href="http://en.wikipedia.org/wiki/Tr_(Unix)">tr</a>
(short for transliterate) does just this, it takes one range of characters that you specify and changes them into
another range of characters:</p>

<pre><code>$ head -n 2 chr1.fasta

&gt;Chr1 dumped from ADB: Mar/14/08 12:28; last updated: 2007-12-20
CCCTAAACCCTAAACCCTAAACCCTAAACCTCTGAATCCTTAATCCCTAAATCCCTAAATCTTTAAATCCTACATCCAT

$ head -n 2 chr1.fasta | tr 'A-Z' 'a-z'

&gt;chr1 dumped from adb: mar/14/08 12:28; last updated: 2007-12-20
ccctaaaccctaaaccctaaaccctaaacctctgaatccttaatccctaaatccctaaatctttaaatcctacatccat
</code></pre>

<hr />

<h2 id="u40">U40: That&#8217;s what she sed</h2>

<p>The <code>tr</code> command let&#8217;s you change a range of characters into another range. But what if you wanted to change a particular pattern into something completely different? Unix has a very powerful command called <a href="http://en.wikipedia.org/wiki/Sed">sed</a> that is capable of performing a variety of text manipulations. Let&#8217;s assume that you want to change the way the FASTA header looks:</p>

<pre><code>$ head -n 1 chr1.fasta &gt;Chr1 dumped from ADB: Mar/14/08 12:28; last updated: 2007-12-20

$ head -n 1 chr1.fasta | sed 's/Chr1/Chromosome 1/' &gt;Chromosome 1 dumped from ADB: Mar/14/08 12:28; last updated: 2007-12-20
</code></pre>

<p>The &#8216;s&#8217; part of the <code>sed</code> command puts <code>sed</code> in &#8216;substitute&#8217; mode, where you specify one pattern (between the first two forward slashes) to be replaced by another pattern (specified between the second set of forward slashes). Note that this doesn&#8217;t actually change the contents of the file, it just changes the screen output from the previous command in the pipe. We will learn later on how to send the output from a command into a new file.</p>

<hr />

<h2 id="u41">U41: Word up</h2>

<p>For this section we want to work with a different type of file. It is sometimes good to get a feeling for how large a file is before you start running lots of commands against it. The <code>ls -l</code> command will tell you how big a file is, but for many purposes it is often more desirable to know how many &#8216;lines&#8217; it has. That is because many Unix commands like <code>grep</code> and <code>sed</code> work on a line by line basis. Fortunately, there is a simple Unix command called <a href="http://en.wikipedia.org/wiki/Wc_(Unix)">wc</a> (word count) that does this:</p>

<pre><code>$ cd Data/Arabidopsis/ $ wc At_genes.gff 531497 4783473 39322356 At_genes.gff
</code></pre>

<p>The three numbers in the output above count the number of lines, words and bytes in the specified file(s). If we had run <code>wc -l</code>, the <code>-l</code> option would have shown us just the line count.</p>

<hr />

<h2 id="u42">U42: GFF and the art of redirection</h2>

<p>The Arabidopsis directory also contains a <a href="http://www.sanger.ac.uk/Software/formats/GFF/">GFF file</a>. This is a common file format in bioinformatics and GFF files are used to describe the location of various features on a DNA sequence. Features can be exons, genes, binding sites etc, and the sequence can be a single gene or (more commonly) an entire chromosome.</p>

<p>This GFF file describes of all of the gene-related features from chromosome I of <em>A. thaliana</em>. We want to play around with some of this data, but don&#8217;t need all of the file&#8230;just 10,000 lines will do (rather than the ~500,000 lines in the original). We will create a new (smaller) file that contains a subset of the original:</p>

<pre><code>$ head -n 10000 At_genes.gff &gt; At_genes_subset.gff 
$ ls -l 
total 195360 
-rwxrwxrwx  1 keith  staff  39322356 Jul  9 15:02 At_genes.gff 
-rwxrwxrwx  1 keith  staff    705370 Jul 10 13:33 At_genes_subset.gff 
-rwxrwxrwx  1 keith  staf f 17836225 Oct  9  2008 At_proteins.fasta 
-rwxrwxrwx  1 keith  staff  30817851 May  7  2008 chr1.fasta 
-rwxrwxrwx  1 keith  staff  11330285 Jul 10 11:11 intron_IME_data.fasta
</code></pre>

<p>This step introduces a new concept. Up till now we have sent the output of any command to the screen (this is the default behavior of Unix commands), or through a pipe to another program. Sometimes you just want to redirect the output into an actual file, and that is what the <code>&gt;</code> symbol is doing, it acts as one of three <a href="http://en.wikipedia.org/wiki/Redirection_(Unix)">redirection operators</a> in Unix.</p>

<p>As already mentioned, the GFF file that we are working with is a standard file format in bioinformatics. For now, all you really need to know is that every GFF file has 9 fields, each separated with a tab character. There should always be some text at every position (even if it is just a &#8216;.&#8217; character). The last field often is used to store a lot of text.</p>

<hr />

<h2 id="u43">U43: Not just a pipe dream</h2>

<p>The 2nd and/or 3rd fields of a GFF file are usually used to describe some sort of biological feature. We might be interested in seeing how many different features are in our file:</p>

<pre><code>$ cut -f 3 At_genes_subset.gff | sort | uniq

CDS 
chromosome 
exon 
five_prime_UTR 
gene 
mRNA 
miRNA 
ncRNA 
protein 
pseudogene 
pseudogenic_exon 
pseudogenic_transcript 
snoRNA 
tRNA 
three_prime_UTR 
transposable_element_gene
</code></pre>

<p>In this example, we combine three separate Unix commands together in one go. Let&#8217;s break it down (it can be useful to just run each command one at at time to see how each additional command is modifying the preceding output):</p>

<ol>
<li>The <a href="http://en.wikipedia.org/wiki/Cut_(Unix)">cut</a> command first takes the At_genes_subset.gff file and &#8216;cuts&#8217; out just the 3rd column (as specified by the <code>-f</code> option). Luckily, the default behavior for the <code>cut</code> command is to split text files into columns based on tab characters (if the columns were separated by another character such as a comma then we would need to use another command line option to specify the comma).</li>
<li>The <a href="http://en.wikipedia.org/wiki/Sort_(Unix)">sort</a> command takes the output of the cut command and sorts it alphanumerically.</li>
<li>The <a href="http://en.wikipedia.org/wiki/Uniq_(Unix)">uniq</a> command (in its default format) only keeps lines which are unique to the output (otherwise you would see thousands of fields which said &#8216;curated&#8217;, &#8216;Coding_transcript&#8217; etc.)</li>
</ol>

<p>Now let&#8217;s imagine that you might want to find which features start earliest in the chromosome sequence. The start coordinate of features is always specified by column 4 of the GFF file, so:</p>

<pre><code>$ cut -f 3,4 At_genes_subset.gff | sort -n -k 2 | head

chromosome  1 
exon    3631 
five_prime_UTR  3631 
gene    3631 
mRNA    3631 
CDS 3760 
protein 3760 
CDS 3996 
exon    3996 
CDS 4486
</code></pre>

<p>Here we first cut out just two columns of interest (3 &amp; 4) from the GFF file. The <code>-f</code> option of the <code>cut</code> command lets us specify which columns we want to remove. The output is then sorted with the <code>sort</code> command. By default, <code>sort</code> will sort alphanumerically, rather than numerically, so we use the <code>-n</code> option to specify that we want to sort numerically. We have two columns of output at this point and we could sort based on either column. The <code>-k 2</code> specifies that we use the second column. Finally, we use the <code>head</code> command to get just the 10 rows of output. These should be lines from the GFF file that have the lowest starting coordinate.</p>

<hr />

<h2 id="u44">U44: The end of the line</h2>

<p>When you press the return/enter key on your keyboard you may think that this causes the same effect no matter what computer you are using. The visible effects of hitting this key are indeed the same&#8230;if you are in a word processor or text editor, then your cursor will move down one line. However, behind the scenes pressing enter will generate one of two different events (depending on what computer you are using). Technically speaking, pressing enter generates a newline character which is represented internally by either a <em>line feed or carriage return</em> character (actually, Windows uses a combination of both to represent a newline). If this is all sounding confusing, well it is, and it is <a href="http://en.wikipedia.org/wiki/Newline">even more complex</a> than we are revealing here.</p>

<p>The relevance of this to Unix is that you will sometimes receive a text file from someone else which looks fine on their computer, but looks unreadable in the Unix text viewer that you are using. In Unix (and in Perl and other programming languages) the patterns <code>\n</code> and <code>\r</code> can both be used to denote newlines. A common fix for this requires substituting <code>\r</code> for <code>\n</code>.</p>

<p>Use <code>less</code> to look at the Data/Misc/excel_data.csv file. This is a simple 4-line file that was exported from a Mac version of Microsoft Excel. You should see that if you use <code>less</code>, then this appears as one line with the newlines replaced with ^M characters. You can convert these carriage returns into Unix-friendly line-feed characters by using the tr command like so:</p>

<pre><code>$ cd Data/Misc 
$ tr '\r' '\n' &lt; excel_data.csv 
sequence 1,acacagagag 
sequence 2,acacaggggaaa 
sequence 3,ttcacagaga 
sequence 4,cacaccaaacac
</code></pre>

<p>This will convert the characters but not save the resulting output, if you wanted to send this output to a new file you will have to use a second redirect operator:</p>

<pre><code>$ tr '\r' '\n' &lt; excel_data.csv &gt; excel_data_formatted.csv
</code></pre>

<hr />

<h2 id="u45">U45: This one goes to 11</h2>

<p>Finally, let&#8217;s parse the Arabidopsis <code>intron_IME_data.fasta</code> file to see if we can extract a subset of sequences that match criteria based on something in the FASTA header line. Every intron sequence in this file has a header line that contains the following pieces of information:</p>

<ul>
<li>gene name</li>
<li>intron position in gene</li>
<li>distance of intron from transcription start site (TSS)</li>
<li>type of sequence that intron is located in (either CDS or UTR)</li>
</ul>

<p>Let&#8217;s say that we want to extract five sequences from this file that are: a) from first introns, b) in the 5&#8217; UTR, and c) closest to the TSS. Therefore we will need to look for FASTA headers that contain the text &#8216;i1&#8217; (first intron) and also the text &#8216;5UTR&#8217;.</p>

<p>We can use <code>grep</code> to find header lines that match these terms, but this will not let us extract the associated sequences. The distance to the TSS is the number in the FASTA header which comes after the intron position. So we want to find the five introns which have the lowest values.</p>

<p>Before I show you one way of doing this in Unix, think for a moment how you would go about this if you didn&#8217;t know any Unix or Perl&#8230;would it even be something you could do without manually going through a text file and selecting each sequence by eye? Note that this Unix command is so long that &#8212; depending on how you are viewing this document &#8212; it may appear to wrap across two lines. When you type this, it should all be on a single line:</p>

<pre><code>$ tr '\n' '@' &lt; intron_IME_data.fasta | sed 's/&gt;/#&gt;/g' | tr '#' '\n' | grep &quot;i1_.*5UTR&quot; | sort -nk 3 -t &quot;_&quot; | head -n 5 | tr '@' '\n'

&gt;AT4G39070.1_i1_7_5UTR 
GTGTGAAACCAAAACCAAAACAAGTCAATTTGGGGGCATTGAAAGCAAAGGAGAGAGTAG
CTATCAAATCAAGAAAATGAGAGGAAGGAGTTAAAAAAGACAAAGGAAACCTAAGCTGCT
TATCTATAAAGCCAACACATTATTCTTACCCTTTTGCCCACACTTATACCCCATCAACCT
CTACATACACTCACCCACATGAGTGTCTCTACATAAACACTACTATATAGTACTGGTCCA 
AAGGTACAAGTTGAGGGAG

&gt;AT5G38430.1_i1_7_5UTR 
GCTTTTTGCCTCTTACGGTTCTCACTATATAAAGATGACAAAACCAATAGAAAAACAATT 
AAG

&gt;AT1G31820.1_i1_14_5UTR 
GTTTGTACTTCTTTACCTCTCGTAAATGTTTAGACTTTCGTATAAGGATCCAAGAATTTA
TCTGATTGTTTTTTTTTCTTTGTTTCTTTGTGTTGATTCAG

&gt;AT3G12670.1_i1_18_5UTR 
GTAGAATTCGTAAATTTCTTCTGCTCACTTTATTGTTTCGACTCATACCCGATAATCTCT
TCTATGTTTGGTAGAGATATCTTCTCAAAGTCTTATCTTTCCTTACCGTGTTCTGTGTTT 
TTTGATGATTTAG

&gt;AT1G26930.1_i1_19_5UTR 
GTATAATATGAGAGATAGACAAATGTAAAGAAAAACACAGAGAGAAAATTAGTTTAATTA
ATCTCTCAAATATATACAAATATTAAAACTTCTTCTTCTTCAATTACAATTCTCATTCTT
TTTTTCTTGTTCTTATATTGTAGTTGCAAGAAAGTTAAAAGATTTTGACTTTTCTTGTTT 
CAG
</code></pre>

<p>That&#8217;s a long command, but it does a lot. Try to break down each step and work out what it is doing (you will need to consult the man page for some commands maybe). Notice that I use one of the other redirect operators <code>&lt;</code> to read from a file. It took seven Unix commands to do this, but these are all relatively simple Unix commands; it is the combination of them together which makes them so powerful. One might argue that when things get this complex with Unix that it might be easier to do it in Perl!</p>

<hr />

<h2 id="summary">Summary</h2>

<p>Congratulations are due if you have reached this far. If you have learnt (and understood) all of the Unix commands so far then you probably will never need to learn anything more in order to do a lot of productive Unix work. But keep on dipping into the man page for all of these commands to explore them in even further detail.</p>

<p>The following table provides a reminder of most of the commands that we have covered so far. If you include the three, as-yet-unmentioned, commands in the last column, then you will probably be able to achieve &gt;95% of everything that you will ever want to do in Unix (remember, you can use the <code>man</code> command to find out more about <code>top</code>, <code>ps</code>, and <code>kill</code>). The power comes from how you can use combinations of these commands.</p>

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:center;">The absolute basics</th>
	<th style="text-align:center;">File control</th>
	<th style="text-align:center;">Viewing, creating, or editing files</th>
	<th style="text-align:center;">Misc. useful commands</th>
	<th style="text-align:center;">Power commands</th>
	<th style="text-align:center;">Process-related commands</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:center;">ls</td>
	<td style="text-align:center;">mv</td>
	<td style="text-align:center;">less</td>
	<td style="text-align:center;">man</td>
	<td style="text-align:center;">uniq</td>
	<td style="text-align:center;">top</td>
</tr>
<tr>
	<td style="text-align:center;">cd</td>
	<td style="text-align:center;">cp</td>
	<td style="text-align:center;">head</td>
	<td style="text-align:center;">chmod</td>
	<td style="text-align:center;">sort</td>
	<td style="text-align:center;">ps</td>
</tr>
<tr>
	<td style="text-align:center;">pwd</td>
	<td style="text-align:center;">mkdir</td>
	<td style="text-align:center;">tail</td>
	<td style="text-align:center;">source</td>
	<td style="text-align:center;">cut</td>
	<td style="text-align:center;">kill</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">rmdir</td>
	<td style="text-align:center;">touch</td>
	<td style="text-align:center;">wc</td>
	<td style="text-align:center;">tr</td>
	<td style="text-align:center;"></td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">rm</td>
	<td style="text-align:center;">nano</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">grep</td>
	<td style="text-align:center;"></td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">| (pipe)</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">sed</td>
	<td style="text-align:center;"></td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&gt; (write to file)</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;">&lt; (read from file)</td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"></td>
</tr>
</tbody>
</table>
<hr />

<blockquote>
<p>Unix Primer for Biologists by Keith Bradnam &amp; Ian Korf is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 License. Please send feedback, questions, money, or abuse to
<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#107;&#x72;&#x62;&#114;&#x61;&#100;&#110;&#x61;&#x6d;&#x40;&#x75;&#99;&#100;&#x61;&#x76;&#x69;&#x73;&#46;&#x65;&#x64;&#117;">&#107;&#x72;&#x62;&#114;&#97;&#x64;&#110;&#x61;&#x6d;&#x40;&#x75;&#x63;&#x64;&#97;&#x76;&#105;&#x73;&#x2e;&#101;&#x64;&#117;</a> or <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#105;&#102;&#107;&#x6f;&#114;&#102;&#x40;&#117;&#x63;&#x64;&#x61;&#118;&#105;&#x73;&#46;&#x65;&#x64;&#x75;">&#x69;&#102;&#x6b;&#111;&#x72;&#x66;&#x40;&#117;&#x63;&#x64;&#x61;&#x76;&#x69;&#115;&#x2e;&#101;&#100;&#x75;</a>. (c) 2012, all rights reserved.</p>
</blockquote>
